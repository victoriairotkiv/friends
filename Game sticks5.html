<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vibe Lines</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #0a0a0a;
      height: 100%;
      width: 100%;
      font-family: 'Inter', sans-serif;
    }
    canvas {
      display: block;
      cursor: none;
    }
    .ui-panel {
      color: #f0f0f0;
      font-family: 'Roboto Mono', monospace;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      text-align: center;
    }
    #hud {
      position: absolute;
      top: 15px;
      left: 15px;
      padding: 12px 18px;
      z-index: 10;
      display: none;
    }
    #timer {
      width: 200px;
      height: 6px;
      background: rgba(255,255,255,0.15);
      border-radius:3px;
      margin-top:8px;
      overflow:hidden;
    }
    #timerBar {
      width: 100%;
      height:100%;
      background: #fff;
      border-radius:3px;
      transition: width 0.3s ease;
    }
    #game-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 30px 50px;
        z-index: 20;
        font-size: 2.5em;
        font-weight: bold;
        display: none;
    }
    #start-menu {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 30px 50px;
        z-index: 20;
    }
    .game-button {
        font-family: 'Roboto Mono', monospace;
        font-size: 1.2em;
        color: #fff;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 15px 30px;
        border-radius: 12px;
        cursor: pointer;
        transition: background 0.2s ease;
    }
    .game-button:hover {
        background: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <div id="hud" class="ui-panel">
    <div id="info">Score: 0 | Level: 01</div>
    <div id="timer"><div id="timerBar"></div></div>
  </div>
  <div id="game-message" class="ui-panel"></div>
  <div id="start-menu" class="ui-panel">
      <h1>Vibe Lines</h1>
      <button id="start-button" class="game-button">Start Game</button>
  </div>
  <canvas id="vibeCanvas"></canvas>

  <script>
    // Production Readiness: Wrap the entire script in an IIFE to avoid polluting the global scope.
    (() => {
      // --- Game State ---
      let gameState = 'start-menu'; // 'start-menu', 'playing', 'win', 'lose'
      let level = 1;
      let lines = [];
      let score = 0;
      let maxTimeForLevel = 60;
      let timeLeft = 60;
      let timerStarted = false;
      let confetti = [];
      let timerInterval;
      let numLines = 80;
      let animationFrameId;

      // --- Audio State ---
      let synth;
      let audioReady = false;
      const noteQueue = [];

      // --- DOM Elements ---
      const canvas = document.getElementById('vibeCanvas');
      const ctx = canvas.getContext('2d');
      const hud = document.getElementById('hud');
      const info = document.getElementById('info');
      const timerBar = document.getElementById('timerBar');
      const startMenu = document.getElementById('start-menu');
      const startButton = document.getElementById('start-button');
      const gameMessage = document.getElementById('game-message');

      // --- Mouse and Cursor Tracking ---
      const mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      let cursor = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

      // --- SVG Assets for Eyes ---
      const eyeWhiteSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 424.3 424.3"><path d="M212.1 394.8c-100.7 0-182.6-81.9-182.6-182.6S111.4 29.5 212.1 29.5s182.6 81.9 182.6 182.6-81.9 182.6-182.6 182.6Z" style="fill:#fff"/><path d="M212.1 42.9c45.2 0 87.7 17.6 119.7 49.6s49.6 74.5 49.6 119.7-17.6 87.7-49.6 119.7-74.5 49.6-119.7 49.6-87.7-17.6-119.7-49.6-49.6-74.5-49.6-119.7 17.6-87.7 49.6-119.7 74.5-49.6 119.7-49.6m0-26.8c-108.2 0-196 87.8-196 196s87.8 196 196 196 196-87.8 196-196-87.7-196-196-196"/></svg>`;
      const pupilSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 424.3 424.3"><path d="M141 141h142.3v142.3H141z"/><path d="M222.3 159.5h38.8v38.8h-38.8zm-64 88.8h17.8v17.8h-17.8z" style="fill:#fff"/></svg>`;

      const eyeWhiteImg = new Image();
      const pupilImg = new Image();
      eyeWhiteImg.src = `data:image/svg+xml;base64,${btoa(eyeWhiteSVG)}`;
      pupilImg.src = `data:image/svg+xml;base64,${btoa(pupilSVG)}`;

      // --- Functions ---

      function setCanvasSize() {
          const dpr = window.devicePixelRatio || 1;
          canvas.width = window.innerWidth * dpr;
          canvas.height = window.innerHeight * dpr;
          canvas.style.width = `${window.innerWidth}px`;
          canvas.style.height = `${window.innerHeight}px`;
          ctx.scale(dpr, dpr);
      }
      
      function repositionLinesOnResize() {
          const padding = 50; // Keep lines away from the very edge
          for (const line of lines) {
              line.x = Math.max(padding, Math.min(line.x, window.innerWidth - padding));
              line.y = Math.max(padding, Math.min(line.y, window.innerHeight - padding));
          }
      }

      async function initAudio() {
          if (audioReady) return;
          try {
              await Tone.start();
              synth = new Tone.PolySynth(Tone.PluckSynth, { maxPolyphony: 16 }).toDestination();
              synth.set({ volume: -8 });
              new Tone.Loop(time => {
                  if (noteQueue.length > 0) {
                      const note = noteQueue.shift();
                      synth.triggerAttackRelease(note.name, note.duration, time);
                  }
              }, "16n").start(0);
              Tone.Transport.start();
              audioReady = true;
          } catch (e) {
              console.error("Could not start audio", e);
          }
      }

      function setGameState(newState) {
          gameState = newState;
          hud.style.display = 'none';
          gameMessage.style.display = 'none';
          startMenu.style.display = 'none';

          switch (newState) {
              case 'playing':
                  hud.style.display = 'block';
                  break;
              case 'win':
                  gameMessage.textContent = `LEVEL ${level.toString().padStart(2, '0')} COMPLETE!`;
                  gameMessage.style.display = 'block';
                  break;
              case 'lose':
                  gameMessage.innerHTML = `TRY AGAIN<br><span style="font-size: 0.6em; font-weight: normal; opacity: 0.8;">Score: ${score}</span><br><button id="restart-button" class="game-button" style="font-size: 0.5em; margin-top: 20px;">Restart</button>`;
                  gameMessage.style.display = 'block';
                  document.getElementById('restart-button').onclick = startGame;
                  break;
              case 'start-menu':
                  startMenu.style.display = 'block';
                  break;
          }
      }

      function startGame() {
          level = 1;
          initAudio();
          createLines();
          setGameState('playing');
          if (!animationFrameId) {
              draw();
          }
      }

      function nextLevel() {
          level++;
          createLines();
          setGameState('playing');
      }

      function createLines() {
        lines = [];
        score = 0;
        confetti = [];
        maxTimeForLevel = Math.max(20, 60 - (level - 1) * 5);
        timeLeft = maxTimeForLevel;
        clearInterval(timerInterval);
        timerStarted = false;
        timerBar.style.transition = 'none';
        timerBar.style.width = '100%';
        setTimeout(() => { timerBar.style.transition = 'width 0.3s ease'; }, 10);

        const area = window.innerWidth * window.innerHeight;
        const baseDensity = 0.00005;
        const density = baseDensity + (level * 0.000005);
        numLines = Math.floor(area * density);
        const palette = ['#CCCCCC', '#CBA3E3', '#F0FF5A', '#86B9F7', '#EBD9FF', '#FFB998'];
        for (let i = 0; i < numLines; i++) {
          const x = Math.random() * window.innerWidth;
          const y = Math.random() * window.innerHeight;
          const length = 80;
          const angle = Math.random() * Math.PI * 2;
          const color = palette[i % palette.length];
          const z = Math.random();
          const xOffset = Math.cos(angle) * (length / 2);
          const yOffset = Math.sin(angle) * (length / 2);
          lines.push({ x, y, z, angle, length, baseAngle: angle, color, vx: 0, vy: 0, collected: false, end1x: x - xOffset, end1y: y - yOffset, end2x: x + xOffset, end2y: y + yOffset });
        }
      }
      
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const collected = lines.filter(l => l.collected);
        const fallbackX = window.innerWidth / 2;
        const fallbackY = window.innerHeight / 2;
        const avgX = collected.length > 0 ? collected.reduce((sum, l) => sum + l.x, 0) / collected.length : fallbackX;
        const avgY = collected.length > 0 ? collected.reduce((sum, l) => sum + l.y, 0) / collected.length : fallbackY;

        const interactionDistSq = 300 * 300; // OPTIMIZATION: Squared distance for interaction
        const collectionDistSq = 40 * 40; // OPTIMIZATION: Squared distance for collection

        for (const line of lines) {
          const dx = mouse.x - line.x;
          const dy = mouse.y - line.y;
          const distSq = dx * dx + dy * dy; // OPTIMIZATION: Use squared distance for checks

          if (gameState === 'playing') {
              if (distSq < collectionDistSq && !line.collected) {
                line.collected = true;
                score++;
                if (audioReady) {
                    const notes = ['C4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5', 'G5'];
                    noteQueue.push({ name: notes[score % notes.length], duration: '8n' });
                }
              }
          }
          
          if (line.collected) {
            const mouseForce = 0.04; 
            line.vx += dx * mouseForce;
            line.vy += dy * mouseForce;
            if (collected.length > 1) {
                const cohesionForce = 0.01;
                line.vx += (avgX - line.x) * cohesionForce;
                line.vy += (avgY - line.y) * cohesionForce;
            }
          } else {
            // OPTIMIZATION: Only apply repulsion force if mouse is close enough
            if (distSq < interactionDistSq) {
                const dist = Math.sqrt(distSq); // Calculate sqrt only when needed
                const force = Math.min(1500 / (dist * dist + 100), 1);
                const angleToMouse = Math.atan2(dy, dx);
                line.vx += Math.cos(angleToMouse) * force;
                line.vy += Math.sin(angleToMouse) * force;
            }
            const idleSway = Math.sin(Date.now() * 0.0005 + line.z * 5) * 0.008;
            line.angle += idleSway;
          }

          line.vx *= 0.85; 
          line.vy *= 0.85;
          line.x += line.vx * (0.8 + line.z * 0.4); 
          line.y += line.vy * (0.8 + line.z * 0.4);
          const targetAngle = line.baseAngle + 0.5 * Math.sin(Math.atan2(dy, dx) - line.baseAngle);
          line.angle += (targetAngle - line.angle) * 0.1;
          
          if (!line.collected) {
              const blurAmount = (1 - line.z) * 4; // OPTIMIZATION: Reduced max blur amount
              if (blurAmount > 0.3) { ctx.filter = `blur(${blurAmount}px)`; }
          }

          const xOffset = Math.cos(line.angle) * (line.length / 2);
          const yOffset = Math.sin(line.angle) * (line.length / 2);
          const lagFactor = 0.5;
          line.end1x += (line.x - xOffset - line.end1x) * lagFactor;
          line.end1y += (line.y - yOffset - line.end1y) * lagFactor;
          line.end2x += (line.x + xOffset - line.end2x) * lagFactor;
          line.end2y += (line.y + yOffset - line.end2y) * lagFactor;

          ctx.strokeStyle = line.color;
          ctx.globalAlpha = 0.5 + line.z * 0.5; 
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(line.end1x, line.end1y);
          ctx.quadraticCurveTo(line.x, line.y, line.end2x, line.end2y);
          ctx.stroke();
          ctx.filter = 'none';
          ctx.globalAlpha = 1;
        }

        if (gameState !== 'start-menu' && eyeWhiteImg.complete && pupilImg.complete) {
          const spacing = 10, size = 20;
          [ -spacing, spacing ].forEach(offset => {
            const eyeX = avgX + offset, eyeY = avgY;
            ctx.drawImage(eyeWhiteImg, eyeX - size / 2, eyeY - size / 2, size, size);
            const dx = cursor.x - eyeX, dy = cursor.y - eyeY;
            const angle = Math.atan2(dy, dx);
            const pupilOffset = size * 0.2;
            const pupilX = eyeX + Math.cos(angle) * pupilOffset;
            const pupilY = eyeY + Math.sin(angle) * pupilOffset;
            const pupilSize = (size / 2) * 2.25;
            ctx.drawImage(pupilImg, pupilX - pupilSize / 2, pupilY - pupilSize / 2, pupilSize, pupilSize);
          });
        }

        for (let i = confetti.length - 1; i >= 0; i--) {
          const c = confetti[i];
          c.y += c.speed; c.angle += c.rotationSpeed; c.life--;
          const xOffset = Math.cos(c.angle) * (c.length / 2);
          const yOffset = Math.sin(c.angle) * (c.length / 2);
          ctx.strokeStyle = c.color; ctx.lineWidth = 3; ctx.beginPath();
          ctx.moveTo(c.x - xOffset, c.y - yOffset);
          ctx.lineTo(c.x + xOffset, c.y + yOffset);
          ctx.stroke();
          if (c.life <= 0 || c.y > window.innerHeight + c.length) { confetti.splice(i, 1); }
        }
        
        if (gameState === 'playing' && score >= numLines) {
          setGameState('win');
          clearInterval(timerInterval);
          if (audioReady) { noteQueue.push({ name: ["C4", "E4", "G4", "C5"], duration: "2n" }); }
          for (let i = 0; i < 200; i++) {
              confetti.push({ x: Math.random() * window.innerWidth, y: -Math.random() * window.innerHeight, length: 30 + Math.random() * 30, angle: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.1, speed: Math.random() * 3 + 2, color: lines[i % lines.length]?.color || '#FFFFFF', life: 300 });
          }
          setTimeout(nextLevel, 3000);
        }

        if (gameState === 'playing') {
          const levelStr = level.toString().padStart(2, '0');
          info.textContent = `Score: ${score}/${numLines} | Level ${levelStr}`;
          timerBar.style.width = `${(timeLeft / maxTimeForLevel) * 100}%`;
        }

        mouse.x += (cursor.x - mouse.x) * 0.2;
        mouse.y += (cursor.y - mouse.y) * 0.2;
        ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(cursor.x, cursor.y, 5, 0, Math.PI * 2); ctx.fill();
        
        animationFrameId = requestAnimationFrame(draw);
      }

      // --- Event Listeners ---
      startButton.addEventListener('click', startGame);

      window.addEventListener('resize', () => {
          setCanvasSize();
          repositionLinesOnResize();
      });

      canvas.addEventListener('mousemove', (e) => {
        cursor.x = e.clientX;
        cursor.y = e.clientY;
        if (gameState === 'playing' && !timerStarted) {
          timerStarted = true;
          timerInterval = setInterval(() => {
            if (gameState !== 'playing') return clearInterval(timerInterval);
            timeLeft--;
            if (timeLeft <= 0) {
              timeLeft = 0;
              setGameState('lose');
              if (audioReady) { noteQueue.push({ name: "C2", duration: "1n" }); }
              clearInterval(timerInterval);
            }
          }, 1000);
        }
      });

      window.onerror = function(message, source, lineno, colno, error) {
          if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
          }
          document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: white; font-family: monospace;">
              <h2>An unexpected error occurred.</h2>
              <p>Please refresh the page to try again.</p>
              <p style="color: #ff8a8a; font-size: 0.8em;">Error: ${message}</p>
          </div>`;
          return true;
      };

      // --- Initial Setup ---
      setCanvasSize();
      setGameState('start-menu');
      createLines();
      draw();
    })();
  </script>
</body>
</html>
